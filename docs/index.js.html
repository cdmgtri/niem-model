<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>index.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Component.html">Component</a><ul class='methods'><li data-type='method'><a href="Component.html#.getName">getName</a></li><li data-type='method'><a href="Component.html#.getPrefix">getPrefix</a></li><li data-type='method'><a href="Component.html#.identifiers">identifiers</a></li><li data-type='method'><a href="Component.html#.sortByName">sortByName</a></li><li data-type='method'><a href="Component.html#.sortByQName">sortByQName</a></li></ul></li><li><a href="Facet.html">Facet</a><ul class='methods'><li data-type='method'><a href="Facet.html#.create">create</a></li><li data-type='method'><a href="Facet.html#.identifiers">identifiers</a></li><li data-type='method'><a href="Facet.html#.route">route</a></li></ul></li><li><a href="LocalTerm.html">LocalTerm</a><ul class='methods'><li data-type='method'><a href="LocalTerm.html#.create">create</a></li><li data-type='method'><a href="LocalTerm.html#.identifiers">identifiers</a></li><li data-type='method'><a href="LocalTerm.html#.route">route</a></li></ul></li><li><a href="Logger.html">Logger</a><ul class='methods'><li data-type='method'><a href="Logger.html#objectUpdates">objectUpdates</a></li></ul></li><li><a href="Model.html">Model</a><ul class='methods'><li data-type='method'><a href="Model.html#.create">create</a></li><li data-type='method'><a href="Model.html#.identifiers">identifiers</a></li></ul></li><li><a href="Namespace.html">Namespace</a><ul class='methods'><li data-type='method'><a href="Namespace.html#.create">create</a></li><li data-type='method'><a href="Namespace.html#.identifiers">identifiers</a></li><li data-type='method'><a href="Namespace.html#.sortByPrefix">sortByPrefix</a></li><li data-type='method'><a href="Namespace.html#.sortByStyle">sortByStyle</a></li><li data-type='method'><a href="Namespace.html#.sortByURI">sortByURI</a></li><li data-type='method'><a href="Namespace.html#dependencies">dependencies</a></li><li data-type='method'><a href="Namespace.html#dependents">dependents</a></li><li data-type='method'><a href="Namespace.html#updateDependents">updateDependents</a></li></ul></li><li><a href="NIEM.html">NIEM</a></li><li></li><li><a href="NIEMModelFormatInterface.html">NIEMModelFormatInterface</a><ul class='methods'><li data-type='method'><a href="NIEMModelFormatInterface.html#.create">create</a></li></ul></li><li><a href="NIEMObject.html">NIEMObject</a><ul class='methods'><li data-type='method'><a href="NIEMObject.html#.create">create</a></li><li data-type='method'><a href="NIEMObject.html#.identifiers">identifiers</a></li><li data-type='method'><a href="NIEMObject.html#.match">match</a></li><li data-type='method'><a href="NIEMObject.html#.matches">matches</a></li><li data-type='method'><a href="NIEMObject.html#add">add</a></li><li data-type='method'><a href="NIEMObject.html#checkBaselineFields">checkBaselineFields</a></li><li data-type='method'><a href="NIEMObject.html#checkSourceID">checkSourceID</a></li><li data-type='method'><a href="NIEMObject.html#delete">delete</a></li><li data-type='method'><a href="NIEMObject.html#dependencies">dependencies</a></li><li data-type='method'><a href="NIEMObject.html#dependents">dependents</a></li><li data-type='method'><a href="NIEMObject.html#match">match</a></li><li data-type='method'><a href="NIEMObject.html#save">save</a></li><li data-type='method'><a href="NIEMObject.html#updateDependents">updateDependents</a></li><li data-type='method'><a href="NIEMObject.html#updateSource">updateSource</a></li></ul></li><li><a href="NIEMObjectFormatInterface.html">NIEMObjectFormatInterface</a><ul class='methods'><li data-type='method'><a href="NIEMObjectFormatInterface.html#generate">generate</a></li><li data-type='method'><a href="NIEMObjectFormatInterface.html#load">load</a></li><li data-type='method'><a href="NIEMObjectFormatInterface.html#parse">parse</a></li></ul></li><li><a href="Property.html">Property</a><ul class='methods'><li data-type='method'><a href="Property.html#.create">create</a></li><li data-type='method'><a href="Property.html#.createAbstract">createAbstract</a></li><li data-type='method'><a href="Property.html#.createAttribute">createAttribute</a></li><li data-type='method'><a href="Property.html#.createElement">createElement</a></li><li data-type='method'><a href="Property.html#dependents">dependents</a></li><li data-type='method'><a href="Property.html#substitutionDescendants">substitutionDescendants</a></li><li data-type='method'><a href="Property.html#substitutions">substitutions</a></li><li data-type='method'><a href="Property.html#updateDependents">updateDependents</a></li></ul></li><li><a href="Release.html">Release</a><ul class='methods'><li data-type='method'><a href="Release.html#.create">create</a></li><li data-type='method'><a href="Release.html#.identifiers">identifiers</a></li><li data-type='method'><a href="Release.html#.route">route</a></li></ul></li><li><a href="ReleaseObject.html">ReleaseObject</a><ul class='methods'><li data-type='method'><a href="ReleaseObject.html#xsd">xsd</a></li></ul></li><li><a href="SourceDataSet.html">SourceDataSet</a><ul class='methods'><li data-type='method'><a href="SourceDataSet.html#add">add</a></li><li data-type='method'><a href="SourceDataSet.html#count">count</a></li><li data-type='method'><a href="SourceDataSet.html#delete">delete</a></li><li data-type='method'><a href="SourceDataSet.html#edit">edit</a></li><li data-type='method'><a href="SourceDataSet.html#find">find</a></li><li data-type='method'><a href="SourceDataSet.html#get">get</a></li><li data-type='method'><a href="SourceDataSet.html#history">history</a></li><li data-type='method'><a href="SourceDataSet.html#load">load</a></li><li data-type='method'><a href="SourceDataSet.html#modify">modify</a></li><li data-type='method'><a href="SourceDataSet.html#revisions">revisions</a></li><li data-type='method'><a href="SourceDataSet.html#updatePreviousIdentifiers">updatePreviousIdentifiers</a></li></ul></li><li><a href="SourceDataSetInterface.html">SourceDataSetInterface</a><ul class='methods'><li data-type='method'><a href="SourceDataSetInterface.html#add">add</a></li><li data-type='method'><a href="SourceDataSetInterface.html#count">count</a></li><li data-type='method'><a href="SourceDataSetInterface.html#delete">delete</a></li><li data-type='method'><a href="SourceDataSetInterface.html#edit">edit</a></li><li data-type='method'><a href="SourceDataSetInterface.html#find">find</a></li><li data-type='method'><a href="SourceDataSetInterface.html#get">get</a></li><li data-type='method'><a href="SourceDataSetInterface.html#history">history</a></li><li data-type='method'><a href="SourceDataSetInterface.html#revisions">revisions</a></li></ul></li><li><a href="SubProperty.html">SubProperty</a><ul class='methods'><li data-type='method'><a href="SubProperty.html#.create">create</a></li><li data-type='method'><a href="SubProperty.html#.identifiers">identifiers</a></li><li data-type='method'><a href="SubProperty.html#.route">route</a></li><li data-type='method'><a href="SubProperty.html#namespace">namespace</a></li></ul></li><li><a href="Transaction.html">Transaction</a></li><li><a href="Type.html">Type</a><ul class='methods'><li data-type='method'><a href="Type.html#.create">create</a></li><li data-type='method'><a href="Type.html#childDescendantTypes">childDescendantTypes</a></li><li data-type='method'><a href="Type.html#childTypes">childTypes</a></li><li data-type='method'><a href="Type.html#dependents">dependents</a></li><li data-type='method'><a href="Type.html#updateDependents">updateDependents</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#count">count</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#xsd">xsd</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
let NIEMModelSourceMemory = require("./interfaces/source/impl/memory/index");

let NIEMModelSource = require("./interfaces/source/index");

let Model = require("./model/index");
let Release = require("./release/index");
let Namespace = require("./namespace/index");
let LocalTerm = require("./local-term/index");
let Property = require("./property/index");
let Type = require("./type/index");
let Facet = require("./facet/index");
let SubProperty = require("./subproperty/index");

class NIEM {

  /**
   * @param {NIEMModelSource} [source]
   */
  constructor(source) {

    /** @type {NIEMModelSource[]} */
    this.sources = source ? [source] : [new NIEMModelSourceMemory()];

  }

  get models() {

    return {

      /**
       * @param {string} userKey
       * @param {string} modelKey
       * @param {Model.StyleType} [style]
       * @param {string} [description]
       * @param {string} [website]
       * @param {string} [repo]
       */
      add: async (userKey, modelKey, style, description, website, repo) => {
        let model = Model.create(userKey, modelKey, style, description, website, repo);
        model._source = this.sources[0];
        model.niem = this;
        return model.add();
      },

      /**
       * @param {string} userKey
       * @param {string} modelKey
       */
      get: async (userKey, modelKey) => {
        let identifiers = Model.identifiers(userKey, modelKey);
        for (let source of this.sources) {
          let model = await source.models.get(identifiers);
          if (model) return model;
        }
      },

      /**
       * @param {Model.CriteriaType} criteria
       */
      find: async (criteria={}) => {
        let results = [];
        for (let source of this.sources) {
          let models = await source.models.find(criteria);
          results.push(...models);
        }
        return results;
      },

      niem: async () => {
        return this.models.get("niem", "model");
      }

    };

  }

  get releases() {
    return {

      /**
       * @param {string} userKey
       * @param {string} modelKey
       * @param {string} releaseKey
       * @param {string} [niemReleaseKey]
       * @param {"3.0"|"4.0"} [ndrVersion]
       * @param {string} [version]
       * @param {import("./release/index").StatusType} [status]
       * @param {string} [baseURI]
       */
      add: async (userKey, modelKey, releaseKey, niemReleaseKey, ndrVersion, version, status, baseURI) => {
        let model = await this.models.get(userKey, modelKey);

        if (! model) {
          // Create model if not found
          model = await this.models.add(userKey, modelKey);
        }

        return model.releases.add(releaseKey, niemReleaseKey, ndrVersion, version, status, baseURI);
      },

      /**
       * @param {string} userKey
       * @param {string} modelKey
       * @param {string} releaseKey
       * @param {string} niemReleaseKey
       */
      load: async (userKey, modelKey, releaseKey, niemReleaseKey) => {

        // Find or initialize release
        let release = await this.releases.get(userKey, modelKey, releaseKey);
        if (!release) {
          release = await this.releases.add(userKey, modelKey, releaseKey, niemReleaseKey);
        }

        // Return format-specific function that loads data
        return {
          xsd: async (input) => release.load.xsd(input),
          json: async (input) => release.load.json(input)
        };

      },

      /**
       * @param {string} userKey
       * @param {string} modelKey
       * @param {string} releaseKey
       */
      get: async (userKey, modelKey, releaseKey) => {
        let identifiers = Release.identifiers(userKey, modelKey, releaseKey);
        for (let source of this.sources) {
          let release = await source.releases.get(identifiers);
          if (release) return release;
        }
      },

      /**
       * @param {Release.CriteriaType} criteria
       */
      find: async (criteria={}) => {
        let results = [];
        for (let source of this.sources) {
          let releases = await source.releases.find(criteria);
          results.push(...releases);
        }
        return results;
      },

      niem: async (releaseKey) => {
        return this.releases.get("niem", "model", releaseKey);
      }

    };
  }

  get namespaces() {
    return {

      /**
       * @param {string} userKey
       * @param {string} modelKey
       * @param {string} releaseKey
       * @param {string} prefix
       */
      get: async (userKey, modelKey, releaseKey, prefix) => {
        let identifiers = Namespace.identifiers(userKey, modelKey, releaseKey, prefix);
        for (let source of this.sources) {
          let namespace = await source.namespaces.get(identifiers);
          if (namespace) return namespace;
        }
      },

      /**
       * @param {Namespace.CriteriaType} criteria
       */
      find: async (criteria={}) => {
        let results = [];
        for (let source of this.sources) {
          let namespaces = await source.namespaces.find(criteria);
          results.push(...namespaces);
        }
        return results;
      }

    };
  }

  get localTerms() {
    return {

      /**
       * @param {string} userKey
       * @param {string} modelKey
       * @param {string} releaseKey
       * @param {string} prefix
       * @param {string} term
       */
      get: async (userKey, modelKey, releaseKey, prefix, term) => {
        let identifiers = LocalTerm.identifiers(userKey, modelKey, releaseKey, prefix, term);
        for (let source of this.sources) {
          let localTerm = await source.localTerms.get(identifiers);
          if (localTerm) return localTerm;
        }
      },

      /**
       * @param {LocalTerm.CriteriaType} criteria
       */
      find: async (criteria={}) => {
        let results = [];
        for (let source of this.sources) {
          let localTerms = await source.localTerms.find(criteria);
          results.push(...localTerms);
        }
        return results;
      }

    };
  }

  get properties() {
    return {

      /**
       * @param {string} userKey
       * @param {string} modelKey
       * @param {string} releaseKey
       * @param {string} qname
       */
      get: async (userKey, modelKey, releaseKey, qname) => {
        let identifiers = Property.identifiers(userKey, modelKey, releaseKey, Property.getPrefix(qname), Property.getName(qname));
        for (let source of this.sources) {
          let property = await source.properties.get(identifiers);
          if (property) return property;
        }
      },

      /**
       * @param {Property.CriteriaType} criteria
       */
      find: async (criteria={}) => {
        let results = [];
        for (let source of this.sources) {
          let properties = await source.properties.find(criteria);
          results.push(...properties);
        }
        return results;
      }

    };
  }

  get types() {
    return {

      /**
       * @param {string} userKey
       * @param {string} modelKey
       * @param {string} releaseKey
       * @param {string} qname
       */
      get: async (userKey, modelKey, releaseKey, qname) => {
        let identifiers = Type.identifiers(userKey, modelKey, releaseKey, Type.getPrefix(qname), Type.getName(qname));
        for (let source of this.sources) {
          let type = await source.types.get(identifiers);
          if (type) return type;
        }
      },

      /**
       * @param {Type.CriteriaType} criteria
       */
      find: async (criteria={}) => {
        let results = [];
        for (let source of this.sources) {
          let types = await source.types.find(criteria);
          results.push(...types);
        }
        return results;
      }

    };
  }

  get facets() {

    return {

      /**
       * @param {string} userKey
       * @param {string} modelKey
       * @param {string} releaseKey
       * @param {string} typeQName
       * @param {string} value
       * @param {import("./facet/index").StyleType} [style="enumeration"] Default "enumeration"
       * @param {string} definition
       */
      get: async (userKey, modelKey, releaseKey, typeQName, value, style="enumeration", definition) => {
        let identifiers = Facet.identifiers(userKey, modelKey, releaseKey, typeQName, value, style);
        identifiers.definition = definition;
        for (let source of this.sources) {
          let facet = await source.facets.get(identifiers);
          if (facet) return facet;
        }
      },

      /**
       * @param {import("./facet/index").CriteriaType} criteria
       */
      find: async (criteria={}) => {
        let results = [];
        for (let source of this.sources) {
          let facets = await source.facets.find(criteria);
          results.push(...facets);
        }
        return results;
      }

    };
  }

  get subProperties() {
    return {

      /**
       * @param {string} userKey
       * @param {string} modelKey
       * @param {string} releaseKey
       * @param {string} prefix
       * @param {string} name
       */
      get: async (userKey, modelKey, releaseKey, typeQName, propertyQName) => {
        let identifiers = SubProperty.identifiers(userKey, modelKey, releaseKey, typeQName, propertyQName);
        for (let source of this.sources) {
          let subProperty = await source.subProperties.get(identifiers);
          if (subProperty) return subProperty;
        }
      },

      /**
       * @param {SubProperty.CriteriaType} criteria
       */
      find: async (criteria={}) => {
        let results = [];
        for (let source of this.sources) {
          let subProperties = await source.subProperties.find(criteria);
          results.push(...subProperties);
        }
        return results;
      }

    };
  }

}

NIEM.Model = Model;
NIEM.Release = Release;
NIEM.Namespace = Namespace;
NIEM.LocalTerm = LocalTerm;
NIEM.Component = require("./component/index");
NIEM.Property = Property;
NIEM.Type = Type;
NIEM.Facet = Facet;
NIEM.SubProperty = SubProperty;

NIEM.NIEMObject = require("./niem-object/index");
NIEM.ReleaseObject = require("./release-object/index");

NIEM.Interfaces = {
  NIEMSource: {
    NIEMModelSource: require("./interfaces/index"),
    Change: require("./interfaces/source/change/index"),
    Transaction: require("./interfaces/source/transaction/index"),
    DataSet: require("./interfaces/source/dataSet/index")
  },
  NIEMFormat: {
    NIEMModelFormatInterface: require("./interfaces/format/index"),
    NIEMObjectFormatInterface: require("./interfaces/format/niem-object/index")
  }
};

NIEM.Tests = {
  unitTests: require("../test/unit/index"),
  integrationTests: require("../test/integration/index")
};

module.exports = NIEM;

</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Mon Feb 17 2020 17:24:31 GMT-0500 (Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
