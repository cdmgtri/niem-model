

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      release/index.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <link type="text/css" rel="stylesheet" href="styles/custom.css">
  
  <link type="text/css" rel="stylesheet" href="styles/collapse.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      NIEM Model Classes
    </h3>

    

    <h3>Classes</h3><ul><li id="Component-nav"><a href="Component.html">Component</a><ul class='methods'><li data-type="method" id="Component-getName-nav"><a href="Component.html#.getName">getName</a></li><li data-type="method" id="Component-getPrefix-nav"><a href="Component.html#.getPrefix">getPrefix</a></li><li data-type="method" id="Component-identifiers-nav"><a href="Component.html#.identifiers">identifiers</a></li><li data-type="method" id="Component-sortByCoreQName-nav"><a href="Component.html#.sortByCoreQName">sortByCoreQName</a></li><li data-type="method" id="Component-sortByName-nav"><a href="Component.html#.sortByName">sortByName</a></li><li data-type="method" id="Component-sortByNameCaseSensitive-nav"><a href="Component.html#.sortByNameCaseSensitive">sortByNameCaseSensitive</a></li><li data-type="method" id="Component-sortByNameFunction-nav"><a href="Component.html#.sortByNameFunction">sortByNameFunction</a></li><li data-type="method" id="Component-sortByQName-nav"><a href="Component.html#.sortByQName">sortByQName</a></li><li data-type="method" id="Component-sortListByNamespaceStyle-nav"><a href="Component.html#.sortListByNamespaceStyle">sortListByNamespaceStyle</a></li><li data-type="method" id="Component-namespace-nav"><a href="Component.html#namespace">namespace</a></li></ul></li><li id="DataSet-nav"><a href="DataSet.html">DataSet</a><ul class='methods'><li data-type="method" id="DataSet-add-nav"><a href="DataSet.html#add">add</a></li><li data-type="method" id="DataSet-count-nav"><a href="DataSet.html#count">count</a></li><li data-type="method" id="DataSet-delete-nav"><a href="DataSet.html#delete">delete</a></li><li data-type="method" id="DataSet-edit-nav"><a href="DataSet.html#edit">edit</a></li><li data-type="method" id="DataSet-find-nav"><a href="DataSet.html#find">find</a></li><li data-type="method" id="DataSet-get-nav"><a href="DataSet.html#get">get</a></li><li data-type="method" id="DataSet-history-nav"><a href="DataSet.html#history">history</a></li><li data-type="method" id="DataSet-id-nav"><a href="DataSet.html#id">id</a></li><li data-type="method" id="DataSet-load-nav"><a href="DataSet.html#load">load</a></li><li data-type="method" id="DataSet-modify-nav"><a href="DataSet.html#modify">modify</a></li><li data-type="method" id="DataSet-revisions-nav"><a href="DataSet.html#revisions">revisions</a></li><li data-type="method" id="DataSet-updatePreviousIdentifiers-nav"><a href="DataSet.html#updatePreviousIdentifiers">updatePreviousIdentifiers</a></li></ul></li><li id="DataSetInterface-nav"><a href="DataSetInterface.html">DataSetInterface</a><ul class='methods'><li data-type="method" id="DataSetInterface-add-nav"><a href="DataSetInterface.html#add">add</a></li><li data-type="method" id="DataSetInterface-count-nav"><a href="DataSetInterface.html#count">count</a></li><li data-type="method" id="DataSetInterface-delete-nav"><a href="DataSetInterface.html#delete">delete</a></li><li data-type="method" id="DataSetInterface-edit-nav"><a href="DataSetInterface.html#edit">edit</a></li><li data-type="method" id="DataSetInterface-find-nav"><a href="DataSetInterface.html#find">find</a></li><li data-type="method" id="DataSetInterface-get-nav"><a href="DataSetInterface.html#get">get</a></li><li data-type="method" id="DataSetInterface-history-nav"><a href="DataSetInterface.html#history">history</a></li><li data-type="method" id="DataSetInterface-id-nav"><a href="DataSetInterface.html#id">id</a></li><li data-type="method" id="DataSetInterface-revisions-nav"><a href="DataSetInterface.html#revisions">revisions</a></li></ul></li><li id="Facet-nav"><a href="Facet.html">Facet</a><ul class='methods'><li data-type="method" id="Facet-create-nav"><a href="Facet.html#.create">create</a></li><li data-type="method" id="Facet-identifiers-nav"><a href="Facet.html#.identifiers">identifiers</a></li><li data-type="method" id="Facet-route-nav"><a href="Facet.html#.route">route</a></li><li data-type="method" id="Facet-sortFacetsByStyleAdjustedValueDefinition-nav"><a href="Facet.html#.sortFacetsByStyleAdjustedValueDefinition">sortFacetsByStyleAdjustedValueDefinition</a></li><li data-type="method" id="Facet-sortFacetsByStyleValueDefinition-nav"><a href="Facet.html#.sortFacetsByStyleValueDefinition">sortFacetsByStyleValueDefinition</a></li><li data-type="method" id="Facet-sortFacetsByValue-nav"><a href="Facet.html#.sortFacetsByValue">sortFacetsByValue</a></li></ul></li><li id="LocalTerm-nav"><a href="LocalTerm.html">LocalTerm</a><ul class='methods'><li data-type="method" id="LocalTerm-create-nav"><a href="LocalTerm.html#.create">create</a></li><li data-type="method" id="LocalTerm-identifiers-nav"><a href="LocalTerm.html#.identifiers">identifiers</a></li><li data-type="method" id="LocalTerm-route-nav"><a href="LocalTerm.html#.route">route</a></li><li data-type="method" id="LocalTerm-sortByPrefixTerm-nav"><a href="LocalTerm.html#.sortByPrefixTerm">sortByPrefixTerm</a></li><li data-type="method" id="LocalTerm-sortByTerm-nav"><a href="LocalTerm.html#.sortByTerm">sortByTerm</a></li></ul></li><li id="Mapping-nav"><a href="Mapping.html">Mapping</a></li><li id="Mappings-nav"><a href="Mappings.html">Mappings</a><ul class='methods'><li data-type="method" id="Mappings-add-nav"><a href="Mappings.html#add">add</a></li><li data-type="method" id="Mappings-addMultiple-nav"><a href="Mappings.html#addMultiple">addMultiple</a></li><li data-type="method" id="Mappings-calculate-nav"><a href="Mappings.html#calculate">calculate</a></li><li data-type="method" id="Mappings-find-nav"><a href="Mappings.html#find">find</a></li><li data-type="method" id="Mappings-get-nav"><a href="Mappings.html#get">get</a></li><li data-type="method" id="Mappings-load-nav"><a href="Mappings.html#load">load</a></li></ul></li><li id="Model-nav"><a href="Model.html">Model</a><ul class='methods'><li data-type="method" id="Model-create-nav"><a href="Model.html#.create">create</a></li><li data-type="method" id="Model-identifiers-nav"><a href="Model.html#.identifiers">identifiers</a></li></ul></li><li id="Namespace-nav"><a href="Namespace.html">Namespace</a><ul class='methods'><li data-type="method" id="Namespace-create-nav"><a href="Namespace.html#.create">create</a></li><li data-type="method" id="Namespace-defaultStyle-nav"><a href="Namespace.html#.defaultStyle">defaultStyle</a></li><li data-type="method" id="Namespace-identifiers-nav"><a href="Namespace.html#.identifiers">identifiers</a></li><li data-type="method" id="Namespace-sortByPrefix-nav"><a href="Namespace.html#.sortByPrefix">sortByPrefix</a></li><li data-type="method" id="Namespace-sortByStyle-nav"><a href="Namespace.html#.sortByStyle">sortByStyle</a></li><li data-type="method" id="Namespace-sortByURI-nav"><a href="Namespace.html#.sortByURI">sortByURI</a></li><li data-type="method" id="Namespace-dependencies-nav"><a href="Namespace.html#dependencies">dependencies</a></li><li data-type="method" id="Namespace-dependencyList-nav"><a href="Namespace.html#dependencyList">dependencyList</a></li><li data-type="method" id="Namespace-dependencyNamespaces-nav"><a href="Namespace.html#dependencyNamespaces">dependencyNamespaces</a></li><li data-type="method" id="Namespace-dependencyReferences-nav"><a href="Namespace.html#dependencyReferences">dependencyReferences</a></li><li data-type="method" id="Namespace-dependents-nav"><a href="Namespace.html#dependents">dependents</a></li><li data-type="method" id="Namespace-updateDependents-nav"><a href="Namespace.html#updateDependents">updateDependents</a></li></ul></li><li id="NIEM-nav"><a href="NIEM.html">NIEM</a><ul class='methods'><li data-type="method" id="NIEM-export-nav"><a href="NIEM.html#export">export</a></li><li data-type="method" id="NIEM-load-nav"><a href="NIEM.html#load">load</a></li><li data-type="method" id="NIEM-loadFile-nav"><a href="NIEM.html#loadFile">loadFile</a></li></ul></li><li id="NIEMFormatInterface-nav"><a href="NIEMFormatInterface.html">NIEMFormatInterface</a></li><li id="NIEMObject-nav"><a href="NIEMObject.html">NIEMObject</a><ul class='methods'><li data-type="method" id="NIEMObject-addMultiple-nav"><a href="NIEMObject.html#.addMultiple">addMultiple</a></li><li data-type="method" id="NIEMObject-create-nav"><a href="NIEMObject.html#.create">create</a></li><li data-type="method" id="NIEMObject-identifiers-nav"><a href="NIEMObject.html#.identifiers">identifiers</a></li><li data-type="method" id="NIEMObject-match-nav"><a href="NIEMObject.html#.match">match</a></li><li data-type="method" id="NIEMObject-matches-nav"><a href="NIEMObject.html#.matches">matches</a></li><li data-type="method" id="NIEMObject-route-nav"><a href="NIEMObject.html#.route">route</a></li><li data-type="method" id="NIEMObject-add-nav"><a href="NIEMObject.html#add">add</a></li><li data-type="method" id="NIEMObject-checkBaselineFields-nav"><a href="NIEMObject.html#checkBaselineFields">checkBaselineFields</a></li><li data-type="method" id="NIEMObject-checkSourceID-nav"><a href="NIEMObject.html#checkSourceID">checkSourceID</a></li><li data-type="method" id="NIEMObject-delete-nav"><a href="NIEMObject.html#delete">delete</a></li><li data-type="method" id="NIEMObject-dependencies-nav"><a href="NIEMObject.html#dependencies">dependencies</a></li><li data-type="method" id="NIEMObject-dependents-nav"><a href="NIEMObject.html#dependents">dependents</a></li><li data-type="method" id="NIEMObject-match-nav"><a href="NIEMObject.html#match">match</a></li><li data-type="method" id="NIEMObject-save-nav"><a href="NIEMObject.html#save">save</a></li><li data-type="method" id="NIEMObject-updateDependents-nav"><a href="NIEMObject.html#updateDependents">updateDependents</a></li><li data-type="method" id="NIEMObject-updateSource-nav"><a href="NIEMObject.html#updateSource">updateSource</a></li></ul></li><li id="NIEMObjectFormatInterface-nav"><a href="NIEMObjectFormatInterface.html">NIEMObjectFormatInterface</a><ul class='methods'><li data-type="method" id="NIEMObjectFormatInterface-create-nav"><a href="NIEMObjectFormatInterface.html#.create">create</a></li><li data-type="method" id="NIEMObjectFormatInterface-export-nav"><a href="NIEMObjectFormatInterface.html#export">export</a></li><li data-type="method" id="NIEMObjectFormatInterface-load-nav"><a href="NIEMObjectFormatInterface.html#load">load</a></li><li data-type="method" id="NIEMObjectFormatInterface-parse-nav"><a href="NIEMObjectFormatInterface.html#parse">parse</a></li><li data-type="method" id="NIEMObjectFormatInterface-read-nav"><a href="NIEMObjectFormatInterface.html#read">read</a></li><li data-type="method" id="NIEMObjectFormatInterface-stringify-nav"><a href="NIEMObjectFormatInterface.html#stringify">stringify</a></li><li data-type="method" id="NIEMObjectFormatInterface-write-nav"><a href="NIEMObjectFormatInterface.html#write">write</a></li></ul></li><li id="Property-nav"><a href="Property.html">Property</a><ul class='methods'><li data-type="method" id="Property-create-nav"><a href="Property.html#.create">create</a></li><li data-type="method" id="Property-createAbstract-nav"><a href="Property.html#.createAbstract">createAbstract</a></li><li data-type="method" id="Property-createAttribute-nav"><a href="Property.html#.createAttribute">createAttribute</a></li><li data-type="method" id="Property-createElement-nav"><a href="Property.html#.createElement">createElement</a></li><li data-type="method" id="Property-appliesToProperties-nav"><a href="Property.html#appliesToProperties">appliesToProperties</a></li><li data-type="method" id="Property-appliesToTypes-nav"><a href="Property.html#appliesToTypes">appliesToTypes</a></li><li data-type="method" id="Property-dependencies-nav"><a href="Property.html#dependencies">dependencies</a></li><li data-type="method" id="Property-dependents-nav"><a href="Property.html#dependents">dependents</a></li><li data-type="method" id="Property-group-nav"><a href="Property.html#group">group</a></li><li data-type="method" id="Property-groupHead-nav"><a href="Property.html#groupHead">groupHead</a></li><li data-type="method" id="Property-substitutionDescendants-nav"><a href="Property.html#substitutionDescendants">substitutionDescendants</a></li><li data-type="method" id="Property-substitutions-nav"><a href="Property.html#substitutions">substitutions</a></li><li data-type="method" id="Property-type-nav"><a href="Property.html#type">type</a></li><li data-type="method" id="Property-updateDependents-nav"><a href="Property.html#updateDependents">updateDependents</a></li></ul></li><li id="Release-nav"><a href="Release.html">Release</a><ul class='methods'><li data-type="method" id="Release-create-nav"><a href="Release.html#.create">create</a></li><li data-type="method" id="Release-identifiers-nav"><a href="Release.html#.identifiers">identifiers</a></li><li data-type="method" id="Release-route-nav"><a href="Release.html#.route">route</a></li></ul></li><li id="ReleaseObject-nav"><a href="ReleaseObject.html">ReleaseObject</a></li><li id="SubProperty-nav"><a href="SubProperty.html">SubProperty</a><ul class='methods'><li data-type="method" id="SubProperty-create-nav"><a href="SubProperty.html#.create">create</a></li><li data-type="method" id="SubProperty-identifiers-nav"><a href="SubProperty.html#.identifiers">identifiers</a></li><li data-type="method" id="SubProperty-route-nav"><a href="SubProperty.html#.route">route</a></li><li data-type="method" id="SubProperty-sortByCoreTypeProperty-nav"><a href="SubProperty.html#.sortByCoreTypeProperty">sortByCoreTypeProperty</a></li><li data-type="method" id="SubProperty-sortByCoreTypeSequence-nav"><a href="SubProperty.html#.sortByCoreTypeSequence">sortByCoreTypeSequence</a></li><li data-type="method" id="SubProperty-sortByTypeProperty-nav"><a href="SubProperty.html#.sortByTypeProperty">sortByTypeProperty</a></li><li data-type="method" id="SubProperty-sortByTypeSequence-nav"><a href="SubProperty.html#.sortByTypeSequence">sortByTypeSequence</a></li><li data-type="method" id="SubProperty-namespace-nav"><a href="SubProperty.html#namespace">namespace</a></li></ul></li><li id="Transaction-nav"><a href="Transaction.html">Transaction</a></li><li id="Type-nav"><a href="Type.html">Type</a><ul class='methods'><li data-type="method" id="Type-create-nav"><a href="Type.html#.create">create</a></li><li data-type="method" id="Type-childTypes-nav"><a href="Type.html#childTypes">childTypes</a></li><li data-type="method" id="Type-dependents-nav"><a href="Type.html#dependents">dependents</a></li><li data-type="method" id="Type-descendantTypes-nav"><a href="Type.html#descendantTypes">descendantTypes</a></li><li data-type="method" id="Type-updateDependents-nav"><a href="Type.html#updateDependents">updateDependents</a></li></ul></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#addMultiple">addMultiple</a></li><li><a href="global.html#augmentationPoint">augmentationPoint</a></li><li><a href="global.html#calculate">calculate</a></li><li><a href="global.html#compareObject">compareObject</a></li><li><a href="global.html#ComponentIdentifiersType">ComponentIdentifiersType</a></li><li><a href="global.html#containedProperties">containedProperties</a></li><li><a href="global.html#count">count</a></li><li><a href="global.html#facets">facets</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getDataSet">getDataSet</a></li><li><a href="global.html#getParents">getParents</a></li><li><a href="global.html#inheritedProperties">inheritedProperties</a></li><li><a href="global.html#insert">insert</a></li><li><a href="global.html#load">load</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        release/index.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>
let NIEMObject = require("../niem-object/index");

/**
 * A coherent set of namespaces bundled together for a release, IEPD, EIEM, etc.
 */
class Release extends NIEMObject {

  /**
   * @param {string} releaseKey
   * @param {string} niemReleaseKey
   * @param {import("../release-object/index").NDRVersionType} [ndrVersion="5.0"] Defaults to "5.0"
   * @param {string} [version]
   * @param {StatusType} [status]
   * @param {string} [baseURI]
   * @param {string} [branch]
   * @param {string} [description]
   */
  constructor(releaseKey="default", niemReleaseKey="", ndrVersion="5.0", version="", status, baseURI="", branch="", description="") {

    super();

    /** @type {import("../model/index")} */
    this.model;

    this.releaseKey = releaseKey;
    this.niemReleaseKey = niemReleaseKey;
    this.ndrVersion = ndrVersion;
    this.version = version;
    this.status = status;
    this.baseURI = baseURI;
    this.branch = branch;
    this.description = description;
    this.previousReleaseKey = "";

    /** @type {"major"|"minor"|"micro"|"core supplement"|"domain update"|"patch"|"other"|""} */
    this.style = "";

    this.date = "";

  }

  get niem() {
    return this.model.niem;
  }

  get source() {
    return this.model.source;
  }

  /**
   * @param {string} releaseKey
   * @param {string} [niemReleaseKey]
   * @param {"3.0"|"4.0"|"5.0"} [ndrVersion="5.0"] Defaults to "5.0"
   * @param {string} [version]
   * @param {"draft"|"published"} [status]
   * @param {string} [baseURI]
   * @param {string} [branch]
   * @param {string} [description]
   */
  static create(releaseKey, niemReleaseKey, ndrVersion="5.0", version, status, baseURI, branch, description) {
    return new Release(releaseKey, niemReleaseKey, ndrVersion, version, status, baseURI, branch, description);
  }

  get sourceDataSet() {
    return this.source.releases;
  }

  get namespaces() {
    let Namespace = require("../namespace/index");

    /** @type {Mappings&lt;Namespace>} */
    let mappings = (this.source.mappings);

    return {

      /**
       * @param {string} prefix
       * @param {Namespace.StyleType} [style]
       * @param {string} [uri]
       * @param {string} [fileName]
       * @param {string} [definition]
       * @param {string} [version]
       * @param {string} [relativePath]
       * @returns {Promise&lt;Namespace>}
       */
      add: async (prefix, style, uri, fileName, definition, version, relativePath) => {
        // Use Namespace builder to return the right NDR-version of a namespace
        let namespace = Namespace.create(this.ndrVersion, prefix, style, uri, fileName, definition, version);
        namespace.release = this;
        namespace.relativePath = relativePath;
        return namespace.add();
      },

      /**
       * @param {Namespace[]} namespaces
       */
      addMultiple: async(namespaces) => {
        namespaces.forEach( namespace => namespace.release = this );
        return Namespace.addMultiple(this.releaseKey, this.source.namespaces, namespaces);
      },

      /**
       * @param {string} prefix
       */
      get: async (prefix) => {
        return this.source.namespaces.get({...this.identifiers, prefix});
      },

      /**
       * @param {Namespace.CriteriaType} [criteria]
       * @param {Function} [sortFunction]
       */
      find: async (criteria={}, sortFunction) => {
        Object.assign(criteria, this.identifiers);
        return this.source.namespaces.find(criteria, sortFunction);
      },

      /**
       * @param {Namespace.CriteriaType} criteria
       */
      count: async (criteria={}) => {
        Object.assign(criteria, this.identifiers);
        return this.source.namespaces.count(criteria);
      },


      mappings: {

        /**
         * @param {string} newPrefix
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Namespace>>}
         */
        add: async (newPrefix="", changes=[]) => {
          let newID = Namespace.route(this.userKey, this.modelKey, this.releaseKey, newPrefix);

          return mappings.add(this.source.namespaces, this.userKey, this.modelKey, this.releaseKey, "add", "Namespace", "", newID, undefined, changes);
        },

        /**
         * @param {string} oldPrefix
         * @param {string} newPrefix
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Namespace>>}
         */
        edit: async (oldPrefix="", newPrefix="", changes=[]) => {
          let oldID = Namespace.route(this.userKey, this.modelKey, this.previousReleaseKey, oldPrefix);
          let newID = Namespace.route(this.userKey, this.modelKey, this.releaseKey, newPrefix);

          return mappings.add(this.source.namespaces, this.userKey, this.modelKey, this.releaseKey, "edit", "Namespace", oldID, newID, undefined, changes);
        },

        /**
         * @param {string} oldPrefix
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Namespace>>}
         */
        delete: async (oldPrefix="", changes=[]) => {
          let oldID = Namespace.route(this.userKey, this.modelKey, this.previousReleaseKey, oldPrefix);

          return mappings.add(this.source.namespaces, this.userKey, this.modelKey, this.releaseKey, "delete", "Namespace", oldID, "", undefined, changes);
        },

        /**
         * @param {string} prefix
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Namespace>>}
         */
        load: async (prefix="", changes=[]) => {
          let oldID = Namespace.route(this.userKey, this.modelKey, this.previousReleaseKey, prefix);
          let newID = Namespace.route(this.userKey, this.modelKey, this.releaseKey, prefix);

          return mappings.add(this.source.namespaces, this.userKey, this.modelKey, this.releaseKey, "load", "Namespace", oldID, newID, undefined, changes);
        },

        /**
         * @param {Mapping.OperationType} [operation]
         * @returns {Promise&lt;Array&lt;Mapping&lt;Namespace>>>}
         */
        find: async (operation) => {
          /** @type {Mappings.CriteriaType} */
          let criteria = Object.assign({}, this.identifiers, {operation});
          criteria.className = "Namespace";
          return mappings.find(criteria);
        }

      }

    };
  }

  get localTerms() {

    let LocalTerm = require("../local-term/index");

    /** @type {Mappings&lt;LocalTerm>} */
    let mappings = (this.source.mappings);

    return {

      /**
       * @param {string} prefix
       * @param {string} term
       * @param {string} [literal]
       * @param {string} [definition]
       * @returns {Promise&lt;LocalTerm>}
       */
      add: async (prefix, term, literal, definition) => {
        let localTerm = LocalTerm.create(this.ndrVersion, prefix, term, literal, definition);
        localTerm.release = this;
        return localTerm.add();
      },

      /**
       * @param {LocalTerm[]} localTerms
       */
      addMultiple: async(localTerms) => {
        localTerms.forEach( localTerm => localTerm.release = this );
        return LocalTerm.addMultiple(this.releaseKey, this.source.localTerms, localTerms);
      },

      /**
       * @param {string} prefix
       * @param {string} term
       */
      get: async (prefix, term) => {
        return this.source.localTerms.get({...this.identifiers, prefix, term});
      },

      /**
       * @param {LocalTerm.CriteriaType} [criteria]
       * @param {Function} [sortFunction]
       */
      find: async (criteria={}, sortFunction) => {
        Object.assign(criteria, this.identifiers);
        return this.source.localTerms.find(criteria, sortFunction);
      },

      /**
       * @param {LocalTerm.CriteriaType} criteria
       */
      count: async (criteria={}) => {
        Object.assign(criteria, this.identifiers);
        return this.source.localTerms.count(criteria);
      },

      mappings: {

        /**
         * @param {string} newPrefix
         * @param {string} newTerm
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;LocalTerm>>}
         */
        add: async (newPrefix="", newTerm="", changes=[]) => {
          let newID = LocalTerm.route(this.userKey, this.modelKey, this.releaseKey, newPrefix, newTerm);

          return mappings.add(this.source.localTerms, this.userKey, this.modelKey, this.releaseKey, "add", "LocalTerm", "", newID, undefined, changes);
        },

        /**
         * @param {string} oldPrefix
         * @param {string} oldTerm
         * @param {string} newPrefix
         * @param {string} newTerm
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;LocalTerm>>}
         */
        edit: async (oldPrefix="", oldTerm="", newPrefix="", newTerm="", changes=[]) => {
          let oldID = LocalTerm.route(this.userKey, this.modelKey, this.previousReleaseKey, oldPrefix, oldTerm);
          let newID = LocalTerm.route(this.userKey, this.modelKey, this.releaseKey, newPrefix, newTerm);

          return mappings.add(this.source.localTerms, this.userKey, this.modelKey, this.releaseKey, "edit", "LocalTerm", oldID, newID, undefined, changes);
        },

        /**
         * @param {string} oldPrefix
         * @param {string} oldTerm
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;LocalTerm>>}
         */
        delete: async (oldPrefix="", oldTerm="", changes=[]) => {
          let oldID = LocalTerm.route(this.userKey, this.modelKey, this.previousReleaseKey, oldPrefix, oldTerm);

          return mappings.add(this.source.localTerms, this.userKey, this.modelKey, this.releaseKey, "delete", "LocalTerm", oldID, "", undefined, changes);
        },

        /**
         * @param {string} prefix
         * @param {string} term
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;LocalTerm>>}
         */
        load: async (prefix="", term="", changes=[]) => {
          let oldID = LocalTerm.route(this.userKey, this.modelKey, this.previousReleaseKey, prefix, term);
          let newID = LocalTerm.route(this.userKey, this.modelKey, this.releaseKey, prefix, term);

          return mappings.add(this.source.localTerms, this.userKey, this.modelKey, this.releaseKey, "load", "LocalTerm", oldID, newID, undefined, changes);
        },

        /**
         * @param {Mapping.OperationType} [operation]
         * @returns {Promise&lt;Array&lt;Mapping&lt;LocalTerm>>>}
         */
        find: async (operation) => {
          /** @type {Mappings.CriteriaType} */
          let criteria = Object.assign({}, this.identifiers, {operation});
          criteria.className = "LocalTerm";
          return mappings.find(criteria);
        }
      }

    };
  }

  get properties() {

    let Property = require("../property/index");

    /** @type {Mappings&lt;Property>} */
    let mappings = (this.source.mappings);

    return {

      /**
       * @param {string} prefix
       * @param {string} name
       * @param {string} [definition]
       * @param {string} [typeQName]
       * @param {string} [groupQName]
       * @param {boolean} [isElement=true] Defaults to true
       * @param {boolean} [isAbstract=false] Defaults to false
       * @returns {Promise&lt;Property>}
       */
      add: async (prefix, name, definition, typeQName, groupQName, isElement=true, isAbstract=false) => {
        let property = Property.create(prefix, name, definition, typeQName, groupQName, isElement, isAbstract, this.ndrVersion);
        property.release = this;
        return property.add();
      },

      /**
       * @param {Property[]} properties
       */
      addMultiple: async(properties) => {
        properties.forEach( property => property.release = this );
        return Property.addMultiple(this.releaseKey, this.source.properties, properties);
      },

      /**
       * @param {string} qname
       */
      get: async (qname) => {
        return this.source.properties.get({
          ...this.identifiers,
          prefix: Component.getPrefix(qname),
          name: Component.getName(qname)
        });
      },

      /**
       * @param {Property.CriteriaType} [criteria]
       * @param {Function} [sortFunction]
       */
      find: async (criteria={}, sortFunction) => {
        Object.assign(criteria, this.identifiers);
        return this.source.properties.find(criteria, sortFunction);
      },

      /**
       * @param {Property.CriteriaType} criteria
       */
      count: async (criteria={}) => {
        Object.assign(criteria, this.identifiers);
        return this.source.properties.count(criteria);
      },

      mappings: {

        /**
         * @param {string} newQName
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Property>>}
         */
        add: async (newQName="", changes=[]) => {
          let [newPrefix, newName] = newQName.split(":") || ["", ""];
          let newID = Property.route(this.userKey, this.modelKey, this.releaseKey, newPrefix, newName);

          return mappings.add(this.source.properties, this.userKey, this.modelKey, this.releaseKey, "add", "Property", "", newID, undefined, changes);
        },

        /**
         * @param {string} oldQName
         * @param {string} newQName
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Property>>}
         */
        edit: async (oldQName="", newQName="", changes=[]) => {
          let [oldPrefix, oldName] = oldQName.split(":") || ["", ""];
          let [newPrefix, newName] = newQName.split(":") || ["", ""];

          let oldID = Property.route(this.userKey, this.modelKey, this.previousReleaseKey, oldPrefix, oldName);
          let newID = Property.route(this.userKey, this.modelKey, this.releaseKey, newPrefix, newName);

          return mappings.add(this.source.properties, this.userKey, this.modelKey, this.releaseKey, "edit", "Property", oldID, newID, undefined, changes);
        },

        /**
         * @param {string} oldQName
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Property>>}
         */
        delete: async (oldQName="", changes=[]) => {
          let [oldPrefix, oldName] = oldQName.split(":") || ["", ""];
          let oldID = Property.route(this.userKey, this.modelKey, this.previousReleaseKey, oldPrefix, oldName);

          return mappings.add(this.source.properties, this.userKey, this.modelKey, this.releaseKey, "delete", "Property", oldID, "", undefined, changes);
        },

        /**
         * @param {string} qname
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Property>>}
         */
        load: async (qname="", changes=[]) => {
          let [prefix, name] = qname.split(":") || ["", ""];
          let oldID = Property.route(this.userKey, this.modelKey, this.previousReleaseKey, prefix, name);
          let newID = Property.route(this.userKey, this.modelKey, this.releaseKey, prefix, name);

          return mappings.add(this.source.properties, this.userKey, this.modelKey, this.releaseKey, "load", "Property", oldID, newID, undefined, changes);
        },

        /**
         * @param {Mapping.OperationType} [operation]
         * @returns {Promise&lt;Array&lt;Mapping&lt;Property>>>}
         */
        find: async (operation) => {
          /** @type {Mappings.CriteriaType} */
          let criteria = Object.assign({}, this.identifiers, {operation});
          criteria.className = "Property";
          return mappings.find(criteria);
        }

      }

    };
  }

  get types() {

    let Type = require("../type/index");

    /** @type {Mappings&lt;Type>} */
    let mappings = (this.source.mappings);

    return {

      /**
       * @param {string} prefix
       * @param {string} name
       * @param {string} [definition]
       * @param {Type.StyleType} [style]
       * @param {string} [baseQName]
       * @returns {Promise&lt;Type>}
       */
      add: async (prefix, name, definition, style, baseQName) => {
        let type = Type.create(this.ndrVersion, prefix, name, definition, style, baseQName);
        type.release = this;
        return type.add();
      },

      /**
       * @param {Type[]} types
       */
      addMultiple: async(types) => {
        types.forEach( type => type.release = this );
        return Type.addMultiple(this.releaseKey, this.source.types, types);
      },

      /**
       * @param {string} qname
       */
      get: async (qname) => {
        return this.source.types.get({
          ...this.identifiers,
          prefix: Component.getPrefix(qname),
          name: Component.getName(qname)
        });
      },

      /**
       * @param {Type.CriteriaType} [criteria]
       * @param {Function} [sortFunction]
       */
      find: async (criteria={}, sortFunction) => {
        Object.assign(criteria, this.identifiers);
        return this.source.types.find(criteria, sortFunction);
      },

      /**
       * @param {Type.CriteriaType} criteria
       */
      count: async (criteria={}) => {
        Object.assign(criteria, this.identifiers);
        return this.source.types.count(criteria);
      },

      mappings: {

        /**
         * @param {string} newQName
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Type>>}
         */
        add: async (newQName="", changes=[]) => {
          let newID = Type.route(this.userKey, this.modelKey, this.releaseKey, newQName);

          return mappings.add(this.source.types, this.userKey, this.modelKey, this.releaseKey, "add", "Type", "", newID, undefined, changes);
        },

        /**
         * @param {string} oldQName
         * @param {string} newQName
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Type>>}
         */
        edit: async (oldQName="", newQName="", changes=[]) => {
          let oldID = Type.route(this.userKey, this.modelKey, this.previousReleaseKey, oldQName);
          let newID = Type.route(this.userKey, this.modelKey, this.releaseKey, newQName);

          return mappings.add(this.source.types, this.userKey, this.modelKey, this.releaseKey, "edit", "Type", oldID, newID, undefined, changes);
        },

        /**
         * @param {string} oldQName
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Type>>}
         */
        delete: async (oldQName="", changes=[]) => {
          let oldID = Type.route(this.userKey, this.modelKey, this.previousReleaseKey, oldQName);

          return mappings.add(this.source.types, this.userKey, this.modelKey, this.releaseKey, "delete", "Type", oldID, "", undefined, changes);
        },

        /**
         * @param {string} qname
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Type>>}
         */
        load: async (qname="", changes=[]) => {
          let oldID = Type.route(this.userKey, this.modelKey, this.previousReleaseKey, qname);
          let newID = Type.route(this.userKey, this.modelKey, this.releaseKey, qname);

          return mappings.add(this.source.types, this.userKey, this.modelKey, this.releaseKey, "load", "Type", oldID, newID, undefined, changes);
        },

        /**
         * @param {Mapping.OperationType} [operation]
         * @returns {Promise&lt;Array&lt;Mapping&lt;Type>>>}
         */
        find: async (operation) => {
          /** @type {Mappings.CriteriaType} */
          let criteria = Object.assign({}, this.identifiers, {operation});
          criteria.className = "Type";
          return mappings.find(criteria);
        }

      }


    };
  }

  get facets() {

    let Facet = require("../facet/index");

    /** @type {Mappings&lt;Facet>} */
    let mappings = (this.source.mappings);

    return {

      /**
       * @param {string} typeQName
       * @param {string} value
       * @param {string} [definition]
       * @param {Facet.StyleType} [style="enumeration"] Default "enumeration"
       * @returns {Promise&lt;Facet>}
       */
      add: async (typeQName, value, definition, style="enumeration") => {
        let facet = Facet.create(this.ndrVersion, typeQName, value, definition, style);
        facet.release = this;
        return facet.add();
      },

      /**
       * @param {Facet[]} facets
       */
      addMultiple: async(facets) => {
        facets.forEach( facet => facet.release = this );
        return Facet.addMultiple(this.releaseKey, this.source.facets, facets);
      },

      /**
       * @param {string} qname
       * @param {string} value
       * @param {Facet.StyleType} [style="enumeration"] Default "enumeration"
       */
      get: async (qname, value, style="enumeration") => {
        return this.source.facets.get({...this.identifiers, typeQName: qname, value, style});
      },

      /**
       * @param {Facet.CriteriaType} [criteria]
       * @param {Function} [sortFunction]
       */
      find: async (criteria={}, sortFunction) => {
        Object.assign(criteria, this.identifiers);
        return this.source.facets.find(criteria, sortFunction);
      },

      /**
       * @param {Facet.CriteriaType} criteria
       */
      count: async (criteria={}) => {
        Object.assign(criteria, this.identifiers);
        return this.source.facets.count(criteria);
      },

      mappings: {

        /**
         * @param {string} newQName
         * @param {string} newValue
         * @param {Facet.StyleType} newStyle
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Facet>>}
         */
        add: async (newQName="", newValue="", newStyle="enumeration", changes=[]) => {
          let newID = Facet.route(this.userKey, this.modelKey, this.releaseKey, newQName, newValue, newStyle);

          return mappings.add(this.source.facets, this.userKey, this.modelKey, this.releaseKey, "add", "Facet", "", newID, undefined, changes);
        },

        /**
         * @param {string} oldQName
         * @param {string} oldValue
         * @param {Facet.StyleType} oldStyle
         * @param {string} newQName
         * @param {string} newValue
         * @param {Facet.StyleType} newStyle
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Facet>>}
         */
        edit: async (oldQName="", oldValue="", oldStyle="enumeration", newQName="", newValue="", newStyle="enumeration", changes=[]) => {
          let oldID = Facet.route(this.userKey, this.modelKey, this.previousReleaseKey, oldQName, oldValue, oldStyle);
          let newID = Facet.route(this.userKey, this.modelKey, this.releaseKey, newQName, newValue, newStyle);

          return mappings.add(this.source.facets, this.userKey, this.modelKey, this.releaseKey, "edit", "Facet", oldID, newID, undefined, changes);
        },

        /**
         * @param {string} oldQName
         * @param {string} oldValue
         * @param {Facet.StyleType} oldStyle
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Facet>>}
         */
        delete: async (oldQName="", oldValue="", oldStyle="enumeration", changes=[]) => {
          let oldID = Facet.route(this.userKey, this.modelKey, this.previousReleaseKey, oldQName, oldValue, oldStyle);

          return mappings.add(this.source.facets, this.userKey, this.modelKey, this.releaseKey, "delete", "Facet", oldID, "", undefined, changes);
        },

        /**
         * @param {string} qname
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;Facet>>}
         */
        load: async (qname="", changes=[]) => {
          let [prefix, name] = qname.split(":") || ["", ""];
          let oldID = Facet.route(this.userKey, this.modelKey, this.previousReleaseKey, prefix, name);
          let newID = Facet.route(this.userKey, this.modelKey, this.releaseKey, prefix, name);

          return mappings.add(this.source.facets, this.userKey, this.modelKey, this.releaseKey, "load", "Facet", oldID, newID, undefined, changes);
        },

        /**
         * @param {Mapping.OperationType} [operation]
         * @returns {Promise&lt;Array&lt;Mapping&lt;Facet>>>}
         */
        find: async (operation) => {
          /** @type {Mappings.CriteriaType} */
          let criteria = Object.assign({}, this.identifiers, {operation});
          criteria.className = "Facet";
          return mappings.find(criteria);
        }

      }


    };
  }

  get subProperties() {

    let SubProperty = require("../subproperty/index");

    /** @type {Mappings&lt;SubProperty>} */
    let mappings = (this.source.mappings);

    return {

      /**
       * @param {string} typeQName
       * @param {string} propertyQName
       * @param {string} [min]
       * @param {string} [max]
       * @param {string} [definition]
       * @param {"element"|"attribute"} [style]
       * @param {Number} [sequence]
       * @returns {Promise&lt;SubProperty>}
       */
      add: async (typeQName, propertyQName, min, max, definition, style, sequence) => {
        let subProperty = SubProperty.create(this.ndrVersion, typeQName, propertyQName, min, max, definition, style, sequence);
        subProperty.release = this;
        return subProperty.add();
      },

      /**
       * @param {SubProperty[]} subProperties
       */
      addMultiple: async(subProperties) => {
        subProperties.forEach( subProperty => subProperty.release = this );
        return SubProperty.addMultiple(this.releaseKey, this.source.subProperties, subProperties);
      },

      /**
       * @param {string} typeQName
       * @param {string} propertyQName
       */
      get: async (typeQName, propertyQName) => {
        return this.source.subProperties.get({...this.identifiers, typeQName, propertyQName});
      },

      /**
       * @param {SubProperty.CriteriaType} [criteria]
       * @param {Function} [sortFunction]
       */
      find: async (criteria={}, sortFunction) => {
        Object.assign(criteria, this.identifiers);
        return this.source.subProperties.find(criteria, sortFunction);
      },

      /**
       * @param {SubProperty.CriteriaType} criteria
       */
      count: async (criteria={}) => {
        Object.assign(criteria, this.identifiers);
        return this.source.subProperties.count(criteria);
      },

      mappings: {

        /**
         * @param {string} newTypeQName
         * @param {string} newPropertyQName
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;SubProperty>>}
         */
        add: async (newTypeQName="", newPropertyQName="", changes=[]) => {
          let newID = SubProperty.route(this.userKey, this.modelKey, this.releaseKey, newTypeQName, newPropertyQName);

          return mappings.add(this.source.subProperties, this.userKey, this.modelKey, this.releaseKey, "add", "SubProperty", "", newID, undefined, changes);
        },

        /**
         * @param {string} oldTypeQName
         * @param {string} oldPropertyQName
         * @param {string} newTypeQName
         * @param {string} newPropertyQName
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;SubProperty>>}
         */
        edit: async (oldTypeQName="", oldPropertyQName="", newTypeQName="", newPropertyQName="", changes=[]) => {
          let oldID = SubProperty.route(this.userKey, this.modelKey, this.previousReleaseKey, oldTypeQName, oldPropertyQName);
          let newID = SubProperty.route(this.userKey, this.modelKey, this.releaseKey, newTypeQName, newPropertyQName);

          return mappings.add(this.source.subProperties, this.userKey, this.modelKey, this.releaseKey, "edit", "SubProperty", oldID, newID, undefined, changes);
        },

        /**
         * @param {string} oldTypeQName
         * @param {string} oldPropertyQName
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;SubProperty>>}
         */
        delete: async (oldTypeQName="", oldPropertyQName="", changes=[]) => {
          let oldID = SubProperty.route(this.userKey, this.modelKey, this.previousReleaseKey, oldTypeQName, oldPropertyQName);

          return mappings.add(this.source.subProperties, this.userKey, this.modelKey, this.releaseKey, "delete", "SubProperty", oldID, "", undefined, changes);
        },

        /**
         * @param {string} typeQName
         * @param {string} propertyQName
         * @param {Change[]} [changes]
         * @returns {Promise&lt;Mapping&lt;SubProperty>>}
         */
        load: async (typeQName="", propertyQName="", changes=[]) => {
          let oldID = SubProperty.route(this.userKey, this.modelKey, this.previousReleaseKey, typeQName, propertyQName);
          let newID = SubProperty.route(this.userKey, this.modelKey, this.releaseKey, typeQName, propertyQName);

          return mappings.add(this.source.subProperties, this.userKey, this.modelKey, this.releaseKey, "load", "SubProperty", oldID, newID, undefined, changes);
        },

        /**
         * @param {Mapping.OperationType} [operation]
         * @returns {Promise&lt;Array&lt;Mapping&lt;SubProperty>>>}
         */
        find: async (operation) => {
          /** @type {Mappings.CriteriaType} */
          let criteria = Object.assign({}, this.identifiers, {operation});
          criteria.className = "SubProperty";
          return mappings.find(criteria);
        }

      }


    };
  }

  get mappings() {
    return {

      /**
       * @param {Mapping.OperationType} operation
       * @param {Mapping.ClassNameType} className
       * @param {string} previousID
       * @param {string} id
       * @param {string[]} differentFields
       * @param {Change[]} changes
       */
      insert: async(operation, className, previousID, id, differentFields=undefined, changes) => {
        let dataSet = getDataSet(this.source, className);
        return this.source.mappings.add(dataSet, this.userKey, this.modelKey, this.releaseKey, operation, className, previousID, id, differentFields, changes);
      },

      /**
       * @param {Mapping.ClassNameType} className
       * @param {Object.&lt;string, any>} oldObject
       * @param {Object.&lt;string, any>} newObject
       * @param {string[]} ignoredFields
       * @param {Change[]} changes
       */
      calculate: (className, oldObject, newObject, ignoredFields, changes) => {
        let dataSet = getDataSet(this.source, className);
        return this.source.mappings.calculate(dataSet, className, oldObject, newObject, ignoredFields, changes);
      },

      /**
       * @param {Object} criteria
       * @param {Mapping.ClassNameType} [criteria.className]
       * @param {Mapping.OperationType} [criteria.operation]
       */
      find: async (criteria={}) => {
        criteria["userKey"] = this.userKey;
        criteria["modelKey"] = this.modelKey;
        criteria["releaseKey"] = this.releaseKey;
        return this.source.mappings.find(criteria);
      }

    }
  }

  get majorDigit() {
    if (!this.releaseKey) return;
    return Number(this.releaseKey[0]);
  }

  async dependents() {
    let namespaces = await this.namespaces.find();
    return { namespaces, count: namespaces.length };
  }

  async loadBuiltIns() {

    // Add XML schema namespace
    let xs = await this.namespaces.add("xs", "built-in", "http://www.w3.org/2001/XMLSchema");

    // Add XML schema simple types
    await xs.types.add("base64Binary", "A data type for Base64-encoded binary data.", "simple");
    await xs.types.add("boolean", "A data type for binary-valued logic (true/false).", "simple");
    await xs.types.add("byte", "A data type that is  is derived from short by setting the value of maxInclusive to be 127 and minInclusive to be -128.", "simple");
    await xs.types.add("anyURI", "anyURI represents a Uniform Resource Identifier Reference (URI).", "simple");
    await xs.types.add("double", "The double datatype is patterned after the IEEE double-precision 64-bit floating point type [IEEE 754-1985].", "simple");
    await xs.types.add("gDay", "gDay is a gregorian day that recurs, specifically a day of the month such as the 5th of the month.", "simple");
    await xs.types.add("date", "A data type for a calendar date with the format CCYY-MM-DD.", "simple");
    await xs.types.add("dateTime", "dateTime values may be viewed as objects with integer-valued year, month, day, hour and minute properties, a decimal-valued second property, and a boolean timezoned property.", "simple");
    await xs.types.add("decimal", "A data type for arbitrary precision decimal numbers.", "simple");
    await xs.types.add("duration", "A data type for a duration of time with the format PnYnMnDTnHnMnS, where nY is the number of years, nM is the number of months, nD is the number of days, nH is the number of hours, nM is the number of minutes, and nS is the number of seconds.", "simple");
    await xs.types.add("gYear", "A data type for a Gregorian calendar year with the format CCYY.", "simple");
    await xs.types.add("gYearMonth", "A data type for a specific gregorian month in a specific gregorian year.", "simple");
    await xs.types.add("float", "A data type that is patterned after the IEEE single-precision 32-bit floating point type [IEEE 754-1985]. The basic value space of float consists of the values m x 2^e, where m is an integer whose absolute value is less than 2^24, and e is an integer between -149 and 104, inclusive. In addition to the basic value space described above, the value space of float also contains the following three special values: positive and negative infinity and not-a-number (NaN).", "simple");
    await xs.types.add("gMonth", "A data type for a Gregorian month with the format --MM--.", "simple");
    await xs.types.add("gMonthDay", "A data type for a gregorian date that recurs, specifically a day of the year such as the third of May. Arbitrary recurring dates are not supported by this datatype. The value space of gMonthDay is the set of calendar dates, as defined in Section 3 of [ISO 8601]. Specifically, it is a set of one-day long, annually periodic instances.", "simple");
    await xs.types.add("language", "A data type that represents natural language identifiers as defined by by [RFC 3066].", "simple");
    await xs.types.add("hexBinary", "A data type for hex-encoded binary data.", "simple");
    await xs.types.add("int", "A data type that is  is derived from long by setting the value of maxInclusive to be 2147483647 and minInclusive to be -2147483648.", "simple");
    await xs.types.add("integer", "A data type for the standard mathematical concept of integer numbers.", "simple");
    await xs.types.add("long", "A data type that is derived from integer by setting the value of maxInclusive to be 9223372036854775807 and minInclusive to be -9223372036854775808.", "simple");
    await xs.types.add("negativeInteger", "A data type that is derived from nonPositiveInteger by setting the value of maxInclusive to be -1.", "simple");
    await xs.types.add("nonNegativeInteger", "A data type for an integer with a minimum value of 0.", "simple");
    await xs.types.add("nonPositiveInteger", "A data type for a lexical representation consisting of an optional preceding sign followed by a finite-length sequence of decimal digits.", "simple");
    await xs.types.add("normalizedString", "A data type that represents white space normalized strings. The value space of normalizedString is the set of strings that do not contain the carriage return, line feed nor tab characters.", "simple");
    await xs.types.add("token", "A data type for tokenized strings.", "simple");
    await xs.types.add("positiveInteger", "positiveInteger is derived from nonNegativeInteger by setting the value of minInclusive to be 1.", "simple");
    await xs.types.add("short", "A data type that is derived from int by setting the value of maxInclusive to be 32767 and minInclusive to be -32768.", "simple");
    await xs.types.add("time", "A data type for an instant of time with the format hh:mm:ss.sss.", "simple");
    await xs.types.add("string", "A data type for character strings in XML.", "simple");
    await xs.types.add("unsignedByte", "A data type that is derived from unsignedShort by setting the value of maxInclusive to be 255.", "simple");
    await xs.types.add("unsignedInt", "A data type that is derived from unsignedLong by setting the value of maxInclusive to be 4294967295.", "simple");
    await xs.types.add("unsignedLong", "A data type that is derived from nonNegativeInteger by setting the value of maxInclusive to be 18446744073709551615.", "simple");
    await xs.types.add("unsignedShort", "A data type that is derived from unsignedInt by setting the value of maxInclusive to be 65535.", "simple");

    // Add XML namespace
    let xml = await this.namespaces.add("xml", "built-in", "");

    // Add attribute xml:lang
    await xml.properties.add("lang", "A human language used in the scope of the element to which it's attached.", undefined, undefined, false);

  }

  async loadUtilities() {

    let structures = await this.namespaces.add("structures", "utility", "", "structures", "");

    await structures.types.add("ObjectType", undefined, "object");
    await structures.types.add("AssociationType", "", "augmentation");
    await structures.types.add("AugmentationType", undefined, "augmentation");

  }

  get modelKey() {
    return this.model.modelKey;
  }

  get userKey() {
    return this.model.userKey;
  }

  get identifiers() {
    return {
      ...this.model.identifiers,
      releaseKey: this.releaseKey
    };
  }

  /**
   * @param {string} userKey
   * @param {string} modelKey
   * @param {string} releaseKey
   */
  static identifiers(userKey, modelKey, releaseKey) {
    return {userKey, modelKey, releaseKey};
  }

  /**
   * @example "niem model 4.0"
   * @example "lapd arrestReport 1.0"
   */
  get label() {
    return this.model.label + " " + this.releaseKey;
  }

  /**
   * @param {string} userKey
   * @param {string} modelKey
   * @param {string} releaseKey
   */
  static route(userKey, modelKey, releaseKey) {
    let Model = require("../model/index");
    return Model.route(userKey, modelKey) + "/" + releaseKey;
  }

  get route() {
    return Release.route(this.userKey, this.modelKey, this.releaseKey);
  }

  get modelRoute() {
    return this.model.route;
  }

  toJSON() {
    return {
      ...super.toJSON(),
      releaseKey: this.releaseKey,
      niemReleaseKey: this.niemReleaseKey,
      version: this.version,
      baseURI: this.baseURI,
      branch: this.branch,
      description: this.description
    };
  }

}

/**
 * @param {import("../interfaces/source/interface")} source
 * @param {Mapping.ClassNameType} className
 */
function getDataSet(source, className) {
  switch (className) {
    case "Namespace":
      return source.namespaces;
    case "LocalTerm":
      return source.localTerms;
    case "Property":
      return source.properties;
    case "Type":
      return source.types;
    case "Facet":
      return source.facets;
    case "SubProperty":
      return source.subProperties;
  }

}

/**
 * @typedef {"draft"|"published"} StatusType
 * @type {StatusType}
 */
Release.ReleaseStatusType;

Release.Statuses = ["draft", "published"];

/**
 * Search criteria for release find operations.
 *
 * @typedef {object} CriteriaType
 * @property {string} [userKey]
 * @property {string} [modelKey]
 * @property {string} [releaseKey]
 * @property {string} [niemReleaseKey]
 * @property {"draft"|"published"}  [status]
 */
/**
 * @type {CriteriaType}
 */
Release.ReleaseCriteriaType = {};

/**
 * @typedef {object} IdentifiersType
 * @property {string} userKey
 * @property {string} modelKey
 * @property {string} releaseKey
 */
/**
 * @type {IdentifiersType}
 */
Release.ReleaseIdentifiersType;

module.exports = Release;

let Component = require("../component/index");
let Change = require("../interfaces/source/change/index");
let Mapping = require("../interfaces/source/mapping/index");
let Mappings = require("../interfaces/source/mappings/index");
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
