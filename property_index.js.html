

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      property/index.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <link type="text/css" rel="stylesheet" href="styles/custom.css">
  
  <link type="text/css" rel="stylesheet" href="styles/collapse.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      NIEM Model Classes
    </h3>

    

    <h3>Classes</h3><ul><li id="Component-nav"><a href="Component.html">Component</a><ul class='methods'><li data-type="method" id="Component-getName-nav"><a href="Component.html#.getName">getName</a></li><li data-type="method" id="Component-getPrefix-nav"><a href="Component.html#.getPrefix">getPrefix</a></li><li data-type="method" id="Component-identifiers-nav"><a href="Component.html#.identifiers">identifiers</a></li><li data-type="method" id="Component-sortByCoreQName-nav"><a href="Component.html#.sortByCoreQName">sortByCoreQName</a></li><li data-type="method" id="Component-sortByName-nav"><a href="Component.html#.sortByName">sortByName</a></li><li data-type="method" id="Component-sortByNameCaseSensitive-nav"><a href="Component.html#.sortByNameCaseSensitive">sortByNameCaseSensitive</a></li><li data-type="method" id="Component-sortByNameFunction-nav"><a href="Component.html#.sortByNameFunction">sortByNameFunction</a></li><li data-type="method" id="Component-sortByQName-nav"><a href="Component.html#.sortByQName">sortByQName</a></li><li data-type="method" id="Component-sortListByNamespaceStyle-nav"><a href="Component.html#.sortListByNamespaceStyle">sortListByNamespaceStyle</a></li><li data-type="method" id="Component-namespace-nav"><a href="Component.html#namespace">namespace</a></li></ul></li><li id="DataSet-nav"><a href="DataSet.html">DataSet</a><ul class='methods'><li data-type="method" id="DataSet-add-nav"><a href="DataSet.html#add">add</a></li><li data-type="method" id="DataSet-count-nav"><a href="DataSet.html#count">count</a></li><li data-type="method" id="DataSet-delete-nav"><a href="DataSet.html#delete">delete</a></li><li data-type="method" id="DataSet-edit-nav"><a href="DataSet.html#edit">edit</a></li><li data-type="method" id="DataSet-find-nav"><a href="DataSet.html#find">find</a></li><li data-type="method" id="DataSet-get-nav"><a href="DataSet.html#get">get</a></li><li data-type="method" id="DataSet-history-nav"><a href="DataSet.html#history">history</a></li><li data-type="method" id="DataSet-id-nav"><a href="DataSet.html#id">id</a></li><li data-type="method" id="DataSet-load-nav"><a href="DataSet.html#load">load</a></li><li data-type="method" id="DataSet-modify-nav"><a href="DataSet.html#modify">modify</a></li><li data-type="method" id="DataSet-revisions-nav"><a href="DataSet.html#revisions">revisions</a></li><li data-type="method" id="DataSet-updatePreviousIdentifiers-nav"><a href="DataSet.html#updatePreviousIdentifiers">updatePreviousIdentifiers</a></li></ul></li><li id="DataSetInterface-nav"><a href="DataSetInterface.html">DataSetInterface</a><ul class='methods'><li data-type="method" id="DataSetInterface-add-nav"><a href="DataSetInterface.html#add">add</a></li><li data-type="method" id="DataSetInterface-count-nav"><a href="DataSetInterface.html#count">count</a></li><li data-type="method" id="DataSetInterface-delete-nav"><a href="DataSetInterface.html#delete">delete</a></li><li data-type="method" id="DataSetInterface-edit-nav"><a href="DataSetInterface.html#edit">edit</a></li><li data-type="method" id="DataSetInterface-find-nav"><a href="DataSetInterface.html#find">find</a></li><li data-type="method" id="DataSetInterface-get-nav"><a href="DataSetInterface.html#get">get</a></li><li data-type="method" id="DataSetInterface-history-nav"><a href="DataSetInterface.html#history">history</a></li><li data-type="method" id="DataSetInterface-id-nav"><a href="DataSetInterface.html#id">id</a></li><li data-type="method" id="DataSetInterface-revisions-nav"><a href="DataSetInterface.html#revisions">revisions</a></li></ul></li><li id="Facet-nav"><a href="Facet.html">Facet</a><ul class='methods'><li data-type="method" id="Facet-create-nav"><a href="Facet.html#.create">create</a></li><li data-type="method" id="Facet-identifiers-nav"><a href="Facet.html#.identifiers">identifiers</a></li><li data-type="method" id="Facet-route-nav"><a href="Facet.html#.route">route</a></li><li data-type="method" id="Facet-sortFacetsByStyleAdjustedValueDefinition-nav"><a href="Facet.html#.sortFacetsByStyleAdjustedValueDefinition">sortFacetsByStyleAdjustedValueDefinition</a></li><li data-type="method" id="Facet-sortFacetsByStyleValueDefinition-nav"><a href="Facet.html#.sortFacetsByStyleValueDefinition">sortFacetsByStyleValueDefinition</a></li><li data-type="method" id="Facet-sortFacetsByValue-nav"><a href="Facet.html#.sortFacetsByValue">sortFacetsByValue</a></li></ul></li><li id="LocalTerm-nav"><a href="LocalTerm.html">LocalTerm</a><ul class='methods'><li data-type="method" id="LocalTerm-create-nav"><a href="LocalTerm.html#.create">create</a></li><li data-type="method" id="LocalTerm-identifiers-nav"><a href="LocalTerm.html#.identifiers">identifiers</a></li><li data-type="method" id="LocalTerm-route-nav"><a href="LocalTerm.html#.route">route</a></li><li data-type="method" id="LocalTerm-sortByPrefixTerm-nav"><a href="LocalTerm.html#.sortByPrefixTerm">sortByPrefixTerm</a></li><li data-type="method" id="LocalTerm-sortByTerm-nav"><a href="LocalTerm.html#.sortByTerm">sortByTerm</a></li></ul></li><li id="Mapping-nav"><a href="Mapping.html">Mapping</a></li><li id="Mappings-nav"><a href="Mappings.html">Mappings</a><ul class='methods'><li data-type="method" id="Mappings-add-nav"><a href="Mappings.html#add">add</a></li><li data-type="method" id="Mappings-addMultiple-nav"><a href="Mappings.html#addMultiple">addMultiple</a></li><li data-type="method" id="Mappings-calculate-nav"><a href="Mappings.html#calculate">calculate</a></li><li data-type="method" id="Mappings-find-nav"><a href="Mappings.html#find">find</a></li><li data-type="method" id="Mappings-get-nav"><a href="Mappings.html#get">get</a></li><li data-type="method" id="Mappings-load-nav"><a href="Mappings.html#load">load</a></li></ul></li><li id="Model-nav"><a href="Model.html">Model</a><ul class='methods'><li data-type="method" id="Model-create-nav"><a href="Model.html#.create">create</a></li><li data-type="method" id="Model-identifiers-nav"><a href="Model.html#.identifiers">identifiers</a></li></ul></li><li id="Namespace-nav"><a href="Namespace.html">Namespace</a><ul class='methods'><li data-type="method" id="Namespace-create-nav"><a href="Namespace.html#.create">create</a></li><li data-type="method" id="Namespace-defaultStyle-nav"><a href="Namespace.html#.defaultStyle">defaultStyle</a></li><li data-type="method" id="Namespace-identifiers-nav"><a href="Namespace.html#.identifiers">identifiers</a></li><li data-type="method" id="Namespace-sortByPrefix-nav"><a href="Namespace.html#.sortByPrefix">sortByPrefix</a></li><li data-type="method" id="Namespace-sortByStyle-nav"><a href="Namespace.html#.sortByStyle">sortByStyle</a></li><li data-type="method" id="Namespace-sortByURI-nav"><a href="Namespace.html#.sortByURI">sortByURI</a></li><li data-type="method" id="Namespace-dependencies-nav"><a href="Namespace.html#dependencies">dependencies</a></li><li data-type="method" id="Namespace-dependencyList-nav"><a href="Namespace.html#dependencyList">dependencyList</a></li><li data-type="method" id="Namespace-dependencyNamespaces-nav"><a href="Namespace.html#dependencyNamespaces">dependencyNamespaces</a></li><li data-type="method" id="Namespace-dependencyReferences-nav"><a href="Namespace.html#dependencyReferences">dependencyReferences</a></li><li data-type="method" id="Namespace-dependents-nav"><a href="Namespace.html#dependents">dependents</a></li><li data-type="method" id="Namespace-updateDependents-nav"><a href="Namespace.html#updateDependents">updateDependents</a></li></ul></li><li id="NIEM-nav"><a href="NIEM.html">NIEM</a><ul class='methods'><li data-type="method" id="NIEM-export-nav"><a href="NIEM.html#export">export</a></li><li data-type="method" id="NIEM-load-nav"><a href="NIEM.html#load">load</a></li><li data-type="method" id="NIEM-loadFile-nav"><a href="NIEM.html#loadFile">loadFile</a></li></ul></li><li id="NIEMFormatInterface-nav"><a href="NIEMFormatInterface.html">NIEMFormatInterface</a></li><li id="NIEMObject-nav"><a href="NIEMObject.html">NIEMObject</a><ul class='methods'><li data-type="method" id="NIEMObject-addMultiple-nav"><a href="NIEMObject.html#.addMultiple">addMultiple</a></li><li data-type="method" id="NIEMObject-create-nav"><a href="NIEMObject.html#.create">create</a></li><li data-type="method" id="NIEMObject-identifiers-nav"><a href="NIEMObject.html#.identifiers">identifiers</a></li><li data-type="method" id="NIEMObject-match-nav"><a href="NIEMObject.html#.match">match</a></li><li data-type="method" id="NIEMObject-matches-nav"><a href="NIEMObject.html#.matches">matches</a></li><li data-type="method" id="NIEMObject-route-nav"><a href="NIEMObject.html#.route">route</a></li><li data-type="method" id="NIEMObject-add-nav"><a href="NIEMObject.html#add">add</a></li><li data-type="method" id="NIEMObject-checkBaselineFields-nav"><a href="NIEMObject.html#checkBaselineFields">checkBaselineFields</a></li><li data-type="method" id="NIEMObject-checkSourceID-nav"><a href="NIEMObject.html#checkSourceID">checkSourceID</a></li><li data-type="method" id="NIEMObject-delete-nav"><a href="NIEMObject.html#delete">delete</a></li><li data-type="method" id="NIEMObject-dependencies-nav"><a href="NIEMObject.html#dependencies">dependencies</a></li><li data-type="method" id="NIEMObject-dependents-nav"><a href="NIEMObject.html#dependents">dependents</a></li><li data-type="method" id="NIEMObject-match-nav"><a href="NIEMObject.html#match">match</a></li><li data-type="method" id="NIEMObject-save-nav"><a href="NIEMObject.html#save">save</a></li><li data-type="method" id="NIEMObject-updateDependents-nav"><a href="NIEMObject.html#updateDependents">updateDependents</a></li><li data-type="method" id="NIEMObject-updateSource-nav"><a href="NIEMObject.html#updateSource">updateSource</a></li></ul></li><li id="NIEMObjectFormatInterface-nav"><a href="NIEMObjectFormatInterface.html">NIEMObjectFormatInterface</a><ul class='methods'><li data-type="method" id="NIEMObjectFormatInterface-create-nav"><a href="NIEMObjectFormatInterface.html#.create">create</a></li><li data-type="method" id="NIEMObjectFormatInterface-export-nav"><a href="NIEMObjectFormatInterface.html#export">export</a></li><li data-type="method" id="NIEMObjectFormatInterface-load-nav"><a href="NIEMObjectFormatInterface.html#load">load</a></li><li data-type="method" id="NIEMObjectFormatInterface-parse-nav"><a href="NIEMObjectFormatInterface.html#parse">parse</a></li><li data-type="method" id="NIEMObjectFormatInterface-read-nav"><a href="NIEMObjectFormatInterface.html#read">read</a></li><li data-type="method" id="NIEMObjectFormatInterface-stringify-nav"><a href="NIEMObjectFormatInterface.html#stringify">stringify</a></li><li data-type="method" id="NIEMObjectFormatInterface-write-nav"><a href="NIEMObjectFormatInterface.html#write">write</a></li></ul></li><li id="Property-nav"><a href="Property.html">Property</a><ul class='methods'><li data-type="method" id="Property-create-nav"><a href="Property.html#.create">create</a></li><li data-type="method" id="Property-createAbstract-nav"><a href="Property.html#.createAbstract">createAbstract</a></li><li data-type="method" id="Property-createAttribute-nav"><a href="Property.html#.createAttribute">createAttribute</a></li><li data-type="method" id="Property-createElement-nav"><a href="Property.html#.createElement">createElement</a></li><li data-type="method" id="Property-appliesToProperties-nav"><a href="Property.html#appliesToProperties">appliesToProperties</a></li><li data-type="method" id="Property-appliesToTypes-nav"><a href="Property.html#appliesToTypes">appliesToTypes</a></li><li data-type="method" id="Property-dependencies-nav"><a href="Property.html#dependencies">dependencies</a></li><li data-type="method" id="Property-dependents-nav"><a href="Property.html#dependents">dependents</a></li><li data-type="method" id="Property-group-nav"><a href="Property.html#group">group</a></li><li data-type="method" id="Property-groupHead-nav"><a href="Property.html#groupHead">groupHead</a></li><li data-type="method" id="Property-substitutionDescendants-nav"><a href="Property.html#substitutionDescendants">substitutionDescendants</a></li><li data-type="method" id="Property-substitutions-nav"><a href="Property.html#substitutions">substitutions</a></li><li data-type="method" id="Property-type-nav"><a href="Property.html#type">type</a></li><li data-type="method" id="Property-updateDependents-nav"><a href="Property.html#updateDependents">updateDependents</a></li></ul></li><li id="Release-nav"><a href="Release.html">Release</a><ul class='methods'><li data-type="method" id="Release-create-nav"><a href="Release.html#.create">create</a></li><li data-type="method" id="Release-identifiers-nav"><a href="Release.html#.identifiers">identifiers</a></li><li data-type="method" id="Release-route-nav"><a href="Release.html#.route">route</a></li></ul></li><li id="ReleaseObject-nav"><a href="ReleaseObject.html">ReleaseObject</a></li><li id="SubProperty-nav"><a href="SubProperty.html">SubProperty</a><ul class='methods'><li data-type="method" id="SubProperty-create-nav"><a href="SubProperty.html#.create">create</a></li><li data-type="method" id="SubProperty-identifiers-nav"><a href="SubProperty.html#.identifiers">identifiers</a></li><li data-type="method" id="SubProperty-route-nav"><a href="SubProperty.html#.route">route</a></li><li data-type="method" id="SubProperty-sortByCoreTypeProperty-nav"><a href="SubProperty.html#.sortByCoreTypeProperty">sortByCoreTypeProperty</a></li><li data-type="method" id="SubProperty-sortByCoreTypeSequence-nav"><a href="SubProperty.html#.sortByCoreTypeSequence">sortByCoreTypeSequence</a></li><li data-type="method" id="SubProperty-sortByTypeProperty-nav"><a href="SubProperty.html#.sortByTypeProperty">sortByTypeProperty</a></li><li data-type="method" id="SubProperty-sortByTypeSequence-nav"><a href="SubProperty.html#.sortByTypeSequence">sortByTypeSequence</a></li><li data-type="method" id="SubProperty-namespace-nav"><a href="SubProperty.html#namespace">namespace</a></li></ul></li><li id="Transaction-nav"><a href="Transaction.html">Transaction</a></li><li id="Type-nav"><a href="Type.html">Type</a><ul class='methods'><li data-type="method" id="Type-create-nav"><a href="Type.html#.create">create</a></li><li data-type="method" id="Type-childTypes-nav"><a href="Type.html#childTypes">childTypes</a></li><li data-type="method" id="Type-dependents-nav"><a href="Type.html#dependents">dependents</a></li><li data-type="method" id="Type-descendantTypes-nav"><a href="Type.html#descendantTypes">descendantTypes</a></li><li data-type="method" id="Type-updateDependents-nav"><a href="Type.html#updateDependents">updateDependents</a></li></ul></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#addMultiple">addMultiple</a></li><li><a href="global.html#augmentationPoint">augmentationPoint</a></li><li><a href="global.html#calculate">calculate</a></li><li><a href="global.html#compareObject">compareObject</a></li><li><a href="global.html#ComponentIdentifiersType">ComponentIdentifiersType</a></li><li><a href="global.html#containedProperties">containedProperties</a></li><li><a href="global.html#count">count</a></li><li><a href="global.html#facets">facets</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getDataSet">getDataSet</a></li><li><a href="global.html#getParents">getParents</a></li><li><a href="global.html#inheritedProperties">inheritedProperties</a></li><li><a href="global.html#insert">insert</a></li><li><a href="global.html#load">load</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        property/index.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>
const Component = require("../component/index");

/**
 * A property represents a concept, idea, or thing. It defines specific semantics and appears in
 * exchanges as the tag or label for a field.
 *
 * Properties may be more commonly known as as elements, attributes, fields, tags, keys, or keywords.
 *
 * @extends {Component&lt;Property>}
 */
class Property extends Component {

  /**
   * @param {string} [prefix] - Prefix of the namespace in which the property is defined
   * @param {string} [name] - Name of the property
   * @param {string} [definition] - Definition of the property
   * @param {string} [typeQName] - Qualified name of the property's data type
   * @param {string} [groupQName] - Qualified name of the property's substitution group head
   * @param {boolean} [isElement=true] - True if element (default); false if attribute
   * @param {boolean} [isAbstract=false] - True if concrete (default); false if abstract
   * @param {boolean} [nillable=true] - True if property can be assigned an explicit null value (default)
   */
  constructor (prefix="", name="", definition="", typeQName="", groupQName="", isElement=true, isAbstract=false, nillable=true) {

    super(prefix, name, definition);

    /**
     * Qualified name of the property's data type
     * @type {string}
     */
    this.typeQName = typeQName;

    /**
     * Qualified name of the property's substitution group head
     * @type {string}
     */
    this.groupQName = groupQName;

    /**
     * True if the property is an element; false if attribute
     * @type {boolean}
     */
    this.isElement = isElement;

    /**
     * True if the property is concrete; false if abstract
     * @type {boolean}
     */
    this.isAbstract = isAbstract;

    /**
     * True if the property can be assigned an explicit null value
     * @type {boolean}
     */
    this.nillable = nillable;

    // Update nillable to false if property is an attribute or an abstract element
    if (!this.isElement || this.isAbstract) {
      this.nillable = false;
    }

    /**
     * Specially-designated properties to which a metadata property may be applied.
     * @type {string[]}
     */
    this.appliesToPropertyQNames = [];

    /**
     * Specially-designated types to which a metadata property may be applied.
     * @type {string[]}
     */
    this.appliesToTypeQNames = [];

  }

  /**
   * Namespace prefix of the property's data type
   * @type {string}
   */
  get typePrefix() {
    return Component.getPrefix(this.typeQName);
  }

  /**
   * Name of the property's data type, without the namespace prefix
   * @type {string}
   */
  get typeName() {
    return Component.getName(this.typeQName);
  }

  /**
   * Namespace prefix of the property's substitution group head
   * @type {string}
   */
  get groupPrefix() {
    return Component.getPrefix(this.groupQName);
  }

  /**
   * Name of the property's substitution group head, without the namespace prefix
   * @type {string}
   */
  get groupName() {
    return Component.getName(this.groupQName);
  }

  /**
   * True if the property is an attribute; false if the property is an element.
   * @type {boolean}
   */
  get isAttribute() {
    return ! this.isElement;
  }

  /**
   * True if the property is a concrete element; false if the property is an abstract element or an attribute.
   * @type {boolean}
   */
  get isConcrete() {
    return ! this.isAbstract;
  }

  /**
   * Style of the property
   * @type {"abstract"|"attribute"|"element"}
   */
  get style() {

    if (this.isAbstract == true) {
      return "abstract";
    }
    if (this.isAttribute == true) {
      return "attribute";
    }
    return "element";

  }

  get sourceDataSet() {
    if (this.source) return this.source.properties;
  }

  /**
   * Gets the substitution group head property for this property.
   * @returns {Promise&lt;Property>}
   */
  async group() {
    return this.release.properties.get(this.groupPrefix + ":" + this.groupName);
  }

  /**
   * Gets the substitution group or substitution group grandparent property
   * @todo Substitution group lookup should recurse to be able to go up multiple levels
   * @returns {Promise&lt;Property>}
   */
  async groupHead() {
    let group = await this.group();

    if (group &amp;&amp; group.group) {
      // The property's substitution group has its own substitution group
      return this.release.properties.get(group.qname);
    }

    return group;
  }

  /**
   * Gets the type object for this property's data type, based on the typeQName value.
   * @returns {Promise&lt;import("../typedefs").Type>}
   */
  async type() {
    return this.release.types.get(this.typeQName);
  }

  /**
   * Gets properties that can be substituted for this property.
   * @param {CriteriaType} [criteria] Optional criteria to filter the results
   * @returns {Promise&lt;Property[]>}
   */
  async substitutions(criteria={}) {
    criteria.groupQName = this.qname;
    return this.release.properties.find(criteria);
  }

  /**
   * Gets immediate and second-level properties that can be substituted for this property.
   * @param {CriteriaType} criteria Optional criteria to filter the results
   * @returns {Promise&lt;Property[]>}
   */
  async substitutionDescendants(criteria={}) {
    criteria.groupQName = this.qname;

    let substitutions = await this.release.properties.find(criteria);

    /** @type {Property[]} */
    let descendantSubstitutions = [];

    for (let childSubstitution of substitutions) {
      criteria.groupQName = childSubstitution.qname;
      let newDescendantSubstitutions = await this.substitutionDescendants(criteria);
      descendantSubstitutions.push(childSubstitution, ...newDescendantSubstitutions);
    }

    return descendantSubstitutions;
  }

  /**
   * Specially-designated types to which a metadata property may be applied.
   * @returns {Promise&lt;import("../typedefs").Type[]>}
   */
  async appliesToTypes() {

    /** @type {import("../typedefs").Type[]} */
    let types = [];

    for (let qname of this.appliesToTypeQNames) {
      let type = await this.release.types.get(qname);
      types.push(type);
    }

    return types;
  }

  /**
   * Specially-designated properties to which a metadata property may be applied.
   * @returns {Promise&lt;Property[]>}
   */
   async appliesToProperties() {

    /** @type {Property[]} */
    let properties = [];

    for (let qname of this.appliesToPropertyQNames) {
      let property = await this.release.properties.get(qname);
      properties.push(property);
    }

    return properties;
  }

  /**
   * Sub-property functions for this property as it may occur under one or more types.
   * - async add(typeQName, [min], [max], [definition]) => SubProperty
   * - async find(criteria) => SubProperty[]
   */
  get subProperties() {

    return {

      /**
       * Adds this property to the specified type.
       * @param {string} typeQName
       * @param {string} [min]
       * @param {string} [max]
       * @param {string} [definition]
       */
      add: async (typeQName, min, max, definition) => {
        return this.release.subProperties.add(typeQName, this.qname, min, max, definition);
      },

      /**
       * Finds all sub-property relationships for which this property participates.
       * @param {import("../subproperty/index").CriteriaType} [criteria] - Optional criteria by which to filter the results
       * @returns {Promise&lt;import("../typedefs").SubProperty[]>}
       */
      find: async (criteria={}) => {
        criteria.propertyQName = this.qname;
        let d = await this.dependencies();
        d.type
        return this.release.subProperties.find(criteria);
      }

    }
  }

  /**
   * Gets an object containing the other objects that this property directly refers to.
   *
   * Useful in helping to determine which namespaces will need to be imported in this property's schema.
   *
   * - type: Data type of this property
   * - group: Substitution group head for this property
   * - count: Number of dependencies (between 0 and 2)
   */
  async dependencies() {

    let type = await this.type();
    let group = await this.group();

    let count = 0;
    if (type) count++;
    if (group) count++;

    return { type, group, count };
  }

  /**
   * Gets an object containing the other objects that refer to this property.
   *
   * Useful in cascading changes when this property is updated or deleted.
   *
   * - substitutions: Properties that may substitute for this property
   * - subProperties: Sub-property relationships that this property is a part of
   * - count:  Number of dependents
   *
   * @param {boolean} [current=true] Defaults to true; false for last saved identifiers
   * @returns {Promise&lt;DependentsTypes>}
   */
  async dependents(current=true) {

    let qname = current ? this.qname : this.previousIdentifiers.prefix + ":" + this.previousIdentifiers.name;

    let substitutions = await this.release.properties.find({ groupQName: qname });
    let subProperties = await this.release.subProperties.find({ propertyQName: qname });

    let count = substitutions.length + subProperties.length;

    return { substitutions, subProperties, count };
  }

  /**
   * Cascades changes when a property is updated or deleted.
   *
   * - edit: Updates the property's qname in references by other components
   * - delete: Deletes the reference to this property from other components
   *
   * @param {"edit"|"delete"} op - Change operation
   * @param {import("../typedefs").Change} [change] - Change description information
   */
  async updateDependents(op, change) {

    await super.updateDependents(op, change);

    let newQName = op == "edit" ? this.qname : null;

    let dependents = await this.dependents(false);

    // Update or delete subproperties (these don't exist without the property)
    for (let subProperty of dependents.subProperties) {
      if (op == "edit") {
        subProperty.propertyQName = newQName;
        await subProperty.save(change);
      }
      else if (op == "delete") {
        await subProperty.delete(change);
      }
    }

    // Update substitutions
    for (let substitution of dependents.substitutions) {
      substitution.groupQName = newQName;
      await substitution.save(change);
    }

    return dependents;

  }

  /**
   * Gets an object with functions that will find any contents that this property may contain or carry.
   *
   * - async facets() - Finds any codes or other facets that this property may contain
   * - async containedProperties() - Finds any properties that this property directly contains
   * - async inheritedProperties() - Finds parent types and the properties those types contain
   * - async base() - Finds the base or parent of this property's data type
   */
  get contents() {

    let self = this;

    return {

      /**
       * Finds any codes or other facets that this property may contain
       */
      async facets() {
        let type = await self.type();
        return type ? type.contents.facets() : [];
      },

      /**
       * Finds any sub-properties that this property may directly contain
       */
      async containedProperties() {
        let type = await self.type();
        return type ? type.contents.containedProperties() : [];
      },

      /**
       * Finds parent types and the properties those types contain, e.g., {parentTypeQName: subProperty[]}
       */
      async inheritedProperties() {
        let type = await self.type();
        return type ? type.contents.inheritedProperties() : {};
      },

      async base() {
        let type = await self.type();
        if (type) return type.base();
      }

    }

  }

  /**
   * Creates a new property.
   * @param {string} prefix
   * @param {string} name
   * @param {string} [definition]
   * @param {string} [typeQName]
   * @param {string} [groupQName]
   * @param {boolean} [isElement=true]
   * @param {boolean} [isAbstract=false]
   * @param {import("../release-object/index").NDRVersionType} [ndrVersion]
   * @returns {Property}
   */
   static create (prefix, name, definition, typeQName, groupQName, isElement=true, isAbstract=false, ndrVersion) {
    return new Property(prefix, name, definition, typeQName, groupQName, isElement, isAbstract);
  }

  /**
   * @param {import("../typedefs").Release} release
   * @param {string} prefix
   * @param {string} name
   * @param {string} definition
   * @param {string} [typeQName]
   * @param {string} [groupQName]
   * @param {boolean} [isAbstract=false]
   */
  static createElement(release, prefix, name, definition, typeQName, groupQName, isAbstract=false) {
    let property = new Property(prefix, name, definition, typeQName, groupQName, true, isAbstract);
    property.release = release;
    return property;
  }

  /**
   * @param {import("../typedefs").Release} release
   * @param {string} prefix
   * @param {string} name
   * @param {string} definition
   * @param {string} typeQName
   */
  static createAttribute(release, prefix, name, definition, typeQName) {
    let property = new Property(prefix, name, definition, typeQName, null, false, false);
    property.release = release;
    return property;
  }

  /**
   * @param {import("../typedefs").Release} release
   * @param {string} prefix
   * @param {string} name
   * @param {string} definition
   */
  static createAbstract(release, prefix, name, definition) {
    let property = new Property(prefix, name, definition, null, null, true, true);
    property.release = release;
    return property;
  }

  static route(userKey, modelKey, releaseKey, prefix, name) {
    let releaseRoute = super.route(userKey, modelKey, releaseKey);
    return releaseRoute + "/properties/" + prefix + ":" + name;
  }

  get route() {
    return Property.route(this.userKey, this.modelKey, this.releaseKey, this.prefix, this.name);
  }

  toJSON() {
    return {
      ...super.toJSON(),
      typeQName: this.typeQName,
      isElement: this.isElement,
      isAbstract: this.isAbstract,
      groupQName: this.groupQName,
      appliesToTypeQNames: this.appliesToTypeQNames,
      appliesToPropertyQNames: this.appliesToPropertyQNames
    };
  }

}

/**
 * Search criteria options for type find operations.
 *
 * String fields are for exact matches.
 *
 * @typedef {Object} CriteriaType
 * @property {string} [userKey]
 * @property {string} [modelKey]
 * @property {string} [releaseKey]
 * @property {string} [niemReleaseKey]
 * @property {string|string[]} [prefix]
 * @property {string|RegExp} [name]
 * @property {string|RegExp} [definition]
 * @property {string|string[]} [typePrefix]
 * @property {string|RegExp} [typeName]
 * @property {string|string[]|RegExp} [typeQName]
 * @property {string|RegExp} [groupQName]
 * @property {string|RegExp} [groupPrefix]
 * @property {boolean} [isElement]
 * @property {boolean} [isAbstract]
 * @property {string|RegExp} [keyword] - Name, definition, or other text keyword fields
 */
/**
 * @type {CriteriaType}
 */
Property.PropertyCriteriaType;

Property.CriteriaKeywordFields = ["name", "definition"];

/**
 * @typedef {Object} IdentifiersType
 * @property {string} userKey
 * @property {string} modelKey
 * @property {string} releaseKey
 * @property {string} prefix
 * @property {string} name
 */
/**
 * @type {IdentifiersType}
 */
Property.IdentifiersType;

/**
 * @typedef {Object} DependentsTypes
 * @property {Property[]} substitutions
 * @property {Array&lt;import("../subproperty/index")>} subProperties
 * @property {number} count
 */
/**
 * @type {DependentsTypes}
 */
 Property.PropertyDependentsTypes;

module.exports = Property;
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
